// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Bluscream.PropSpawner;
//
//    var propConfig = PropConfig.FromJson(jsonString);

namespace Bluscream.PropSpawner;

using System.Collections.Generic;
using System.Globalization;
using MelonLoader;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

//internal enum PropSelectionMode {
//    All,
//    Random
//}

public partial class PropRule {
    [JsonProperty("worldId", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the gid of the world where this rule will take effect
    /// </summary>
    public virtual List<string> WorldId { get; set; }

    [JsonProperty("worldName", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the name of the world where this rule will take effect
    /// </summary>
    public virtual List<string> WorldName { get; set; }

    [JsonProperty("sceneName", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the name of the unity scene where this rule will take effect
    /// </summary>
    public virtual List<string> SceneName { get; set; }

    [JsonProperty("instancePrivacy", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the instance privacy where this rule will take effect
    /// </summary>
    public virtual List<string> InstancePrivacy { get; set; }



    [JsonProperty("propSelectionRandom", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that when set will force a random prop from the list to be selected everytime
    /// </summary>
    internal virtual bool? PropSelectionRandom { get; set; }

    [JsonProperty("props", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Required field that contains the list of props that spawn if this rule applies
    /// </summary>
    public virtual List<Prop> Props { get; set; }

    public override string ToString() {
        var ruleMatch = WorldId ?? WorldName ?? SceneName ?? InstancePrivacy;
        return $"PropRule \"{ruleMatch}\" ({Props.Count} props{(PropSelectionRandom.Value ? ", random" : "")})";
    }

    public bool Matches(string worldId = null, string worldName = null, string sceneName = null, string instancePrivacy = null) {
        MelonLogger.Warning($"debug PropRule.Matches start {worldId} {worldName} {sceneName} {instancePrivacy}");
        var worldMissing = WorldId is null && SceneName is null && WorldName is null && InstancePrivacy is null;
        //var worldWildcard = WorldId.Any(w => w == "*") && SceneName.Any(w => w == "*") && WorldName.Any(w => w == "*") && InstancePrivacy.Any(w => w == "*");
        var worldIdValid = WorldId != null && WorldId.Any(w => w == worldId);
        var worldNameValid = WorldName != null && WorldName.Any(w => w == worldName);
        var sceneNameValid = SceneName != null && SceneName.Any(s => s == sceneName);
        var instancePrivacyValid = InstancePrivacy != null && SceneName.Any(s => s == instancePrivacy);
        MelonLogger.Warning($"debug PropRule.Matches end worldMissing={worldMissing} worldIdValid={worldIdValid} worldNameValid={worldNameValid} sceneNameValid={sceneNameValid} instancePrivacyValid={instancePrivacyValid}");
        if (worldMissing || worldIdValid || worldNameValid || sceneNameValid || instancePrivacyValid) return true;
        return false;
    }
}

public partial class Prop {
    [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Required field that contains the gid of the prop
    /// </summary>
    public virtual string Id { get; set; }

    [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the name of the prop (unused)
    /// </summary>
    public virtual string Name { get; set; }

    [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the Vector3 Position of the prop to spawn. If omitted, it will spawn at player position
    /// </summary>
    internal virtual List<float>? Position { get; set; }

    [JsonProperty("rotation", NullValueHandling = NullValueHandling.Ignore)]
    /// <summary>
    /// Optional field that contains the Quaternion Rotation of the prop to spawn. If omitted it will spawn with player angles
    /// </summary>
    internal virtual List<float>? Rotation { get; set; }

    public override string ToString() {
        return $"\"{Name}\" ({Id}) at {Extensions.ToString(Position)} ({Extensions.ToString(Rotation)})";
    }
}

public partial class PropConfig {
    public static List<PropRule> FromFile(string filePath) => FromJson(File.ReadAllText(filePath));
    public static List<PropRule> FromJson(string json) => JsonConvert.DeserializeObject<List<PropRule>>(json, Bluscream.PropSpawner.Converter.Settings);
}

public static class Serialize {
    public static string ToJson(this List<PropRule> self) => JsonConvert.SerializeObject(self, Bluscream.PropSpawner.Converter.Settings);
    public static void ToFile(this List<PropRule> self, string filePath) => File.WriteAllText(filePath, self.ToJson());
}

internal static class Converter {
    public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings {
        MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
        DateParseHandling = DateParseHandling.None,
        Formatting = Formatting.Indented,
        Converters = {
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
    };
}
